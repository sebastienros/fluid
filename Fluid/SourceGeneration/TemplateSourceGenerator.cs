using System.IO;
using System.Text;
using Fluid.Ast;
using Microsoft.Extensions.FileProviders;

namespace Fluid.SourceGeneration
{
    public static class TemplateSourceGenerator
    {
        public static TemplateSource Generate(IFluidTemplate template, SourceGenerationOptions options = null)
        {
            if (template == null)
            {
                ExceptionHelper.ThrowArgumentNullException(nameof(template));
            }

            options ??= new SourceGenerationOptions();

            if (template is not IStatementList rootStatementList)
            {
                throw new SourceGenerationException($"{template.GetType().FullName} is not compatible with source generation (it does not expose Statements).");
            }

            // Pre-compile sub-templates referenced by {% render %}
            var renderTemplates = CompileRenderTemplates(rootStatementList, options);

            var sb = new StringBuilder(capacity: 16 * 1024);

            WriteFileHeader(sb);

            sb.Append("namespace ").Append(options.Namespace).AppendLine();
            sb.AppendLine("{");

            // Map render path -> generated type name
            var renderTypeNames = new Dictionary<string, string>(StringComparer.Ordinal);
            foreach (var kv in renderTemplates)
            {
                renderTypeNames[kv.Key] = kv.Value.ClassName;
            }

            // Emit root class
            WriteTemplateClass(sb, options, options.ClassName, rootStatementList, renderTypeNames);

            // Emit subtemplate classes
            foreach (var kv in renderTemplates)
            {
                sb.AppendLine();
                WriteTemplateClass(sb, options, kv.Value.ClassName, kv.Value.Template, renderTypeNames);
            }

            sb.AppendLine("}");

            return new TemplateSource(options.Namespace, options.ClassName, sb.ToString());
        }

        private static void WriteFileHeader(StringBuilder sb)
        {
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using System.IO;");
            sb.AppendLine("using System.Linq;");
            sb.AppendLine("using System.Text.Encodings.Web;");
            sb.AppendLine("using System.Threading.Tasks;");
            sb.AppendLine("using Fluid;");
            sb.AppendLine("using Fluid.Ast;");
            sb.AppendLine("using Fluid.Values;");
            sb.AppendLine();
        }

        private static void WriteTemplateClass(
            StringBuilder sb,
            SourceGenerationOptions options,
            string className,
            IStatementList statementList,
            IReadOnlyDictionary<string, string> renderTemplateTypeNames)
        {
            var ctx = new SourceGenerationContext(sb, options, renderTemplateTypeNames);

            using (ctx.Indent())
            {
                ctx.WriteLine($"internal sealed class {className} : IFluidTemplate");
                ctx.WriteLine("{");
                using (ctx.Indent())
                {
                    ctx.WriteLine("public async ValueTask RenderAsync(TextWriter writer, TextEncoder encoder, TemplateContext context)");
                    ctx.WriteLine("{");
                    using (ctx.Indent())
                    {
                        ctx.WriteLine("if (writer == null) throw new ArgumentNullException(nameof(writer));");
                        ctx.WriteLine("if (encoder == null) throw new ArgumentNullException(nameof(encoder));");
                        ctx.WriteLine("if (context == null) throw new ArgumentNullException(nameof(context));");
                        ctx.WriteLine();

                        foreach (var statement in statementList.Statements)
                        {
                            // Avoid generating and invoking an extra method for pure text spans.
                            // Source generation assumes TemplateOptions.Trimming == TrimmingFlags.None.
                            if (statement is TextSpanStatement textSpan)
                            {
                                if (textSpan.Text.Length == 0)
                                {
                                    continue;
                                }

                                var textField = ctx.GetOrAddStaticString(textSpan.Text.Buffer, textSpan.Text.Offset, textSpan.Text.Length);
                                ctx.WriteLine("context.IncrementSteps();");
                                ctx.WriteLine($"writer.Write({textField});");
                                continue;
                            }

                            var methodName = ctx.GetStatementMethodName(statement);
                            ctx.WriteLine($"_ = await {methodName}(writer, encoder, context);");
                        }
                    }
                    ctx.WriteLine("}");

                    // Drain pending nodes and emit methods.
                    var stmtIndex = 0;
                    var exprIndex = 0;

                    while (stmtIndex < ctx.PendingStatements.Count || exprIndex < ctx.PendingExpressions.Count)
                    {
                        while (exprIndex < ctx.PendingExpressions.Count)
                        {
                            var expression = ctx.PendingExpressions[exprIndex++];
                            var methodName = ctx.GetExpressionMethodName(expression);

                            ctx.WriteLine();
                            ctx.WriteLine($"private static async ValueTask<FluidValue> {methodName}(TemplateContext context)");
                            ctx.WriteLine("{");
                            using (ctx.Indent())
                            {
                                if (expression is ISourceable sourceableExpression)
                                {
                                    sourceableExpression.WriteTo(ctx);
                                }
                                else
                                {
                                    SourceGenerationContext.ThrowNotSourceable(expression);
                                }
                            }
                            ctx.WriteLine("}");
                        }

                        while (stmtIndex < ctx.PendingStatements.Count)
                        {
                            var statement = ctx.PendingStatements[stmtIndex++];
                            var methodName = ctx.GetStatementMethodName(statement);

                            ctx.WriteLine();
                            ctx.WriteLine($"private static async ValueTask<Completion> {methodName}(TextWriter writer, TextEncoder encoder, TemplateContext context)");
                            ctx.WriteLine("{");
                            using (ctx.Indent())
                            {
                                if (statement is ISourceable sourceableStatement)
                                {
                                    sourceableStatement.WriteTo(ctx);
                                }
                                else
                                {
                                    SourceGenerationContext.ThrowNotSourceable(statement);
                                }
                            }
                            ctx.WriteLine("}");
                        }
                    }

                    ctx.WriteStaticMembers();
                }
                ctx.WriteLine("}");
            }
        }

        private sealed record CompiledRenderTemplate(string ClassName, IStatementList Template);

        private static Dictionary<string, CompiledRenderTemplate> CompileRenderTemplates(IStatementList rootTemplate, SourceGenerationOptions options)
        {
            var result = new Dictionary<string, CompiledRenderTemplate>(StringComparer.Ordinal);

            var visitor = new RenderDependencyVisitor();
            foreach (var statement in rootTemplate.Statements)
            {
                visitor.Visit(statement);
            }

            if (visitor.RenderStatements.Count == 0)
            {
                return result;
            }

            if (options.FileProvider == null)
            {
                throw new SourceGenerationException("SourceGenerationOptions.FileProvider is required to compile templates that use the 'render' tag.");
            }

            var queue = new Queue<RenderStatement>(visitor.RenderStatements);
            var id = 0;

            while (queue.Count > 0)
            {
                var render = queue.Dequeue();
                var path = render.Path;

                if (result.ContainsKey(path))
                {
                    continue;
                }

                var content = ReadTemplateContent(options.FileProvider, path);

                if (!render.Parser.TryParse(content, out var parsedTemplate, out var errors))
                {
                    throw new SourceGenerationException($"Failed to parse rendered template '{path}'.", new ParseException(errors));
                }

                if (parsedTemplate is not IStatementList statementList)
                {
                    throw new SourceGenerationException($"Rendered template '{path}' is not compatible with source generation (it does not expose Statements).");
                }

                var className = options.ClassName + "__Render_" + (++id).ToString();
                result[path] = new CompiledRenderTemplate(className, statementList);

                // Enqueue nested render dependencies
                var nestedVisitor = new RenderDependencyVisitor();
                foreach (var statement in statementList.Statements)
                {
                    nestedVisitor.Visit(statement);
                }
                foreach (var nested in nestedVisitor.RenderStatements)
                {
                    if (!result.ContainsKey(nested.Path))
                    {
                        queue.Enqueue(nested);
                    }
                }
            }

            return result;
        }

        private static string ReadTemplateContent(IFileProvider fileProvider, string relativePath)
        {
            var fileInfo = fileProvider.GetFileInfo(relativePath);
            if (fileInfo == null || !fileInfo.Exists || fileInfo.IsDirectory)
            {
                throw new SourceGenerationException($"Rendered template '{relativePath}' was not found in the provided FileProvider.");
            }

            using var stream = fileInfo.CreateReadStream();
            using var reader = new StreamReader(stream);
            return reader.ReadToEnd();
        }
    }
}
