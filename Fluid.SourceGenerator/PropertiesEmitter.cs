using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.CodeAnalysis;

namespace Fluid.SourceGenerator
{
    internal static class PropertiesEmitter
    {
        public static string Emit(INamedTypeSymbol classSymbol, IReadOnlyDictionary<string, string> propertyToTemplateType)
        {
            var ns = classSymbol.ContainingNamespace?.ToDisplayString();

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("using Fluid;");
            sb.AppendLine();

            if (!string.IsNullOrEmpty(ns))
            {
                sb.Append("namespace ").Append(ns).AppendLine();
                sb.AppendLine("{");
            }

            var indent = string.IsNullOrEmpty(ns) ? "" : "    ";

            // Emit containing types chain (supports nested classes).
            var chain = GetContainingTypeChain(classSymbol);
            for (var i = 0; i < chain.Count; i++)
            {
                var type = chain[i];
                sb.Append(indent).Append(GetAccessibility(type)).Append(' ');
                if (type.IsStatic)
                {
                    sb.Append("static ");
                }

                sb.Append("partial class ").Append(type.Name);
                if (type.TypeParameters.Length > 0)
                {
                    sb.Append('<');
                    for (var t = 0; t < type.TypeParameters.Length; t++)
                    {
                        if (t > 0) sb.Append(", ");
                        sb.Append(type.TypeParameters[t].Name);
                    }
                    sb.Append('>');
                }

                sb.AppendLine();
                sb.Append(indent).AppendLine("{");
                indent += "    ";
            }

            foreach (var kv in propertyToTemplateType)
            {
                var prop = kv.Key;
                var typeName = kv.Value;
                var field = "__fluidTemplate_" + prop;

                sb.Append(indent).Append("private static global::Fluid.IFluidTemplate? ").Append(field).AppendLine(";");
                sb.Append(indent).Append("public static global::Fluid.IFluidTemplate ").Append(prop)
                  .Append(" => ").Append(field).Append(" ??= new ").Append(typeName).AppendLine("();");
            }

            for (var i = 0; i < chain.Count; i++)
            {
                indent = indent.Substring(0, Math.Max(0, indent.Length - 4));
                sb.Append(indent).AppendLine("}");
            }

            if (!string.IsNullOrEmpty(ns))
            {
                sb.AppendLine("}");
            }

            return sb.ToString();
        }

        private static List<INamedTypeSymbol> GetContainingTypeChain(INamedTypeSymbol symbol)
        {
            var list = new List<INamedTypeSymbol>();
            INamedTypeSymbol? current = symbol;
            while (current != null)
            {
                list.Insert(0, current);
                current = current.ContainingType;
            }
            return list;
        }

        private static string GetAccessibility(INamedTypeSymbol symbol)
        {
            return symbol.DeclaredAccessibility switch
            {
                Accessibility.Public => "public",
                Accessibility.Internal => "internal",
                Accessibility.Private => "private",
                Accessibility.Protected => "protected",
                Accessibility.ProtectedAndInternal => "protected internal",
                Accessibility.ProtectedOrInternal => "protected internal",
                _ => "internal"
            };
        }
    }
}
